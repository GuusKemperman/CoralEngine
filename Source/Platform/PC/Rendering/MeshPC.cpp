#include "Precomp.h"
#include "Platform/PC/Rendering/MeshPC.h"
#include "Assets/Core/AssetLoadInfo.h"
#include "Assets/Core/AssetSaveInfo.h"
#include "Assets/Asset.h"
#include "Platform/PC/Rendering/DX12Classes/DXResource.h"
#include "Utilities/Reflect/ReflectAssetType.h"
#include "Core/Device.h"
#include "Meta/MetaManager.h"
#include <numeric> 

enum StaticMeshFlags : uint8
{
    hasIndices = 1,
    hasNormals = 1 << 1,
    hasUVs = 1 << 2,
    hasColors = 1 << 3, // No longer used
    areIndices16Bit = 1 << 4,
    hasTangents = 1 << 5
};

namespace
{
    // Function to generate tangent vectors, generated by chatgpt
    std::optional<std::vector<glm::vec3>> CalculateTangents(
        const void* indices,
        size_t numOfIndices,
        bool areIndices16Bit,
        const glm::vec3* positions,
        const glm::vec3* normals,
        const glm::vec2* texCoords,
        size_t numOfVertices);
}

Engine::StaticMesh::StaticMesh(AssetLoadInfo& loadInfo) :
    Asset(loadInfo)
{
    std::istream& str = loadInfo.GetStream();

    StaticMeshFlags flags{};
    str.read(reinterpret_cast<char*>(&flags), sizeof(flags));

    uint32 numOfVertices{};
    str.read(reinterpret_cast<char*>(&numOfVertices), sizeof(numOfVertices));

    std::vector<glm::vec3> positions(numOfVertices);
    str.read(reinterpret_cast<char*>(positions.data()), numOfVertices * sizeof(glm::vec3));

    std::vector<char> indices{};
    const uint32 indicesSizeOfType = flags & areIndices16Bit ? sizeof(uint16) : sizeof(uint32);

    uint32 numOfIndices{};

    if (flags & hasIndices)
    {
        str.read(reinterpret_cast<char*>(&numOfIndices), sizeof(numOfIndices));

        indices.resize(numOfIndices * indicesSizeOfType);
        str.read(reinterpret_cast<char*>(indices.data()), numOfIndices * indicesSizeOfType);
    }
    else
    {
        numOfIndices = static_cast<uint32>(positions.size());
        indices.resize(positions.size());
        std::iota(indices.begin(), indices.end(), 1);
    }

    std::vector<glm::vec3> normalsStorage(0);
    const glm::vec3* normals = nullptr;

    if (flags & hasNormals)
    {
        normalsStorage.resize(numOfVertices);
        str.read(reinterpret_cast<char*>(normalsStorage.data()), numOfVertices * sizeof(glm::vec3));
        normals = normalsStorage.data();
    }

    std::vector<glm::vec2> UVsStorage(0);
    const glm::vec2* UVs = nullptr;

    if (flags & hasUVs)
    {
        UVsStorage.resize(numOfVertices);
        str.read(reinterpret_cast<char*>(UVsStorage.data()), numOfVertices * sizeof(glm::vec2));
        UVs = UVsStorage.data();
    }

    std::vector<glm::vec3> tangentsStorage(0);
    const glm::vec3* tangents = nullptr;

    int loadInfoVersion = loadInfo.GetVersion();
    if (loadInfoVersion == 1
        && flags & hasTangents)
    {
        tangentsStorage.resize(numOfVertices);
        str.read(reinterpret_cast<char*>(tangentsStorage.data()), numOfVertices * sizeof(glm::vec3));
        tangents = tangentsStorage.data();
    }
    else
    {
        std::optional<std::vector<glm::vec3>> optTangents = CalculateTangents(indices.data(), numOfIndices, flags & areIndices16Bit, positions.data(), normals, UVs, numOfVertices);

        if (optTangents.has_value())
        {
            tangentsStorage = std::move(*optTangents);
            tangents = tangentsStorage.data();
        }
    }

    bool meshLoaded = LoadMesh(indices.data(),
        numOfIndices,
        indicesSizeOfType,
        reinterpret_cast<const float*>(&positions.data()->x),
        reinterpret_cast<const float*>(&normals->x),
        reinterpret_cast<const float*>(&UVs->x),
        reinterpret_cast<const float*>(&tangents->x),
        numOfVertices
    );
    
    if (!meshLoaded)
    {
        LOG(LogAssets, Error, "Loading of {} failed: Invalid mesh", GetName());
    }
}

Engine::StaticMesh::StaticMesh(StaticMesh&& other) noexcept:
	Asset(std::move(other))
{
	mVertexBuffer = other.mVertexBuffer;
	mNormalBuffer = other.mNormalBuffer;
	mTangentBuffer = other.mTangentBuffer;
	mTexCoordBuffer = other.mTexCoordBuffer;
	mIndexBuffer = other.mIndexBuffer;

	mVertexBufferView = other.mVertexBufferView;
	mNormalBufferView = other.mNormalBufferView;
	mTexCoordBufferView = other.mTexCoordBufferView;
	mTangentBufferView = other.mTangentBufferView;
	mIndexBufferView = other.mIndexBufferView;

	mIndexCount = other.mIndexCount;
	mVertexCount = other.mVertexCount;
	mIndexFormat = other.mIndexFormat;

}

void Engine::StaticMesh::DrawMesh() const
{
	Device& engineDevice = Device::Get();
	ID3D12GraphicsCommandList4* commandList = reinterpret_cast<ID3D12GraphicsCommandList4*>(engineDevice.GetCommandList());

	commandList->IASetVertexBuffers(0, 1, &mVertexBufferView);
	commandList->IASetVertexBuffers(1, 1, &mNormalBufferView);
	commandList->IASetVertexBuffers(2, 1, &mTexCoordBufferView);
	commandList->IASetVertexBuffers(3, 1, &mTangentBufferView);
	commandList->IASetIndexBuffer(&mIndexBufferView);
	commandList->DrawIndexedInstanced(mIndexCount, 1, 0, 0, 0);
}

bool Engine::StaticMesh::LoadMesh(const char* indices, unsigned int indexCount, unsigned int sizeOfIndexType, const float* positions, const float* normalsBuffer, const float* textureCoordinates, const float* tangents, unsigned int vertexCount)
{
	if (indices == nullptr ||
		indexCount == 0 ||
		positions == nullptr ||
		vertexCount == 0 ||
		sizeOfIndexType == 0) {
		return false;
	}

	switch (sizeOfIndexType)
	{
		case sizeof(unsigned char):			mIndexFormat = DXGI_FORMAT_R8_UINT; break;
			case sizeof(unsigned short):		mIndexFormat = DXGI_FORMAT_R16_UINT; break;
				case sizeof(unsigned int):			mIndexFormat = DXGI_FORMAT_R32_UINT; break;
				default: return false;
	}


	Device& engineDevice = Device::Get();
	ID3D12Device5* device = reinterpret_cast<ID3D12Device5*>(engineDevice.GetDevice());
	ID3D12GraphicsCommandList4* uploadCmdList = reinterpret_cast<ID3D12GraphicsCommandList4*>(engineDevice.GetUploadCommandList());
    engineDevice.StartUploadCommands();
	mIndexCount = indexCount;
	mVertexCount = vertexCount;

	int iBufferSize = sizeOfIndexType * mIndexCount;
	int nBufferSize = sizeof(float) * mVertexCount * 3;
	int tBufferSize = sizeof(float) * mVertexCount * 2;
	int tanBufferSize = sizeof(float) * mVertexCount * 3;

	mVertexBuffer = std::make_shared<DXResource>(device, CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), CD3DX12_RESOURCE_DESC::Buffer(nBufferSize), nullptr, "Vertex resource buffer");
	mTexCoordBuffer = std::make_shared<DXResource>(device, CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), CD3DX12_RESOURCE_DESC::Buffer(tBufferSize), nullptr, "Texture coord resource buffer");
	mNormalBuffer = std::make_shared<DXResource>(device, CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), CD3DX12_RESOURCE_DESC::Buffer(nBufferSize), nullptr, "Normals resource buffer");
	mTangentBuffer = std::make_shared<DXResource>(device, CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), CD3DX12_RESOURCE_DESC::Buffer(tanBufferSize), nullptr, "Tangent resource buffer");

	D3D12_SUBRESOURCE_DATA vData = {};
	vData.pData = positions;
	vData.RowPitch = sizeof(float) * 3;
	vData.SlicePitch = nBufferSize;
	mVertexBuffer->CreateUploadBuffer(device, nBufferSize, 0);
	mVertexBuffer->Update(uploadCmdList, vData, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, 0, 1);

	if (textureCoordinates) {
		D3D12_SUBRESOURCE_DATA tData = {};
		tData.pData = textureCoordinates;
		tData.RowPitch = sizeof(float) * 2;
		tData.SlicePitch = tBufferSize;
		mTexCoordBuffer->CreateUploadBuffer(device, tBufferSize, 0);
		mTexCoordBuffer->Update(uploadCmdList, tData, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, 0, 1);
	}

	if (normalsBuffer) {
		D3D12_SUBRESOURCE_DATA nData = {};
		nData.pData = normalsBuffer;
		nData.RowPitch = sizeof(float) * 3;
		nData.SlicePitch = nBufferSize;
		mNormalBuffer->CreateUploadBuffer(device, nBufferSize, 0);
		mNormalBuffer->Update(uploadCmdList, nData, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, 0, 1);
	}

	if (tangents) {
		D3D12_SUBRESOURCE_DATA tanData = {};
		tanData.pData = tangents;
		tanData.RowPitch = sizeof(float) * 3;
		tanData.SlicePitch = tanBufferSize;
		mTangentBuffer->CreateUploadBuffer(device, tanBufferSize, 0);
		mTangentBuffer->Update(uploadCmdList, tanData, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, 0, 1);
	}

	mIndexBuffer = std::make_unique<DXResource>(device, CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), CD3DX12_RESOURCE_DESC::Buffer(iBufferSize), nullptr, "Index resource buffer");
	D3D12_SUBRESOURCE_DATA iData = {};
	iData.pData = indices;
	iData.RowPitch = iBufferSize;
	iData.SlicePitch = iBufferSize;
	mIndexBuffer->CreateUploadBuffer(device, iBufferSize, 0);
	mIndexBuffer->Update(uploadCmdList, iData, D3D12_RESOURCE_STATE_INDEX_BUFFER, 0, 1);

	mVertexBufferView.BufferLocation = mVertexBuffer->GetResource()->GetGPUVirtualAddress();
	mVertexBufferView.StrideInBytes = sizeof(float) * 3;
	mVertexBufferView.SizeInBytes = nBufferSize;

	mNormalBufferView.BufferLocation = mNormalBuffer->GetResource()->GetGPUVirtualAddress();
	mNormalBufferView.StrideInBytes = sizeof(float) * 3;
	mNormalBufferView.SizeInBytes = nBufferSize;

	mTexCoordBufferView.BufferLocation = mTexCoordBuffer->GetResource()->GetGPUVirtualAddress();
	mTexCoordBufferView.StrideInBytes = sizeof(float) * 2;
	mTexCoordBufferView.SizeInBytes = tBufferSize;

	mTangentBufferView.BufferLocation = mTangentBuffer->GetResource()->GetGPUVirtualAddress();
	mTangentBufferView.StrideInBytes = sizeof(float) * 3;
	mTangentBufferView.SizeInBytes = tanBufferSize;

	mIndexBufferView.BufferLocation = mIndexBuffer->GetResource()->GetGPUVirtualAddress();
	mIndexBufferView.Format = mIndexFormat;
	mIndexBufferView.SizeInBytes = iBufferSize;
    engineDevice.SubmitUploadCommands();
	return true;
}

namespace
{
    std::optional<std::vector<glm::vec3>> CalculateTangents(
        const void* const indices,
        const size_t numOfIndices,
        const bool areIndices16Bit,
        const glm::vec3* const positions,
        const glm::vec3* const normals,
        const glm::vec2* const texCoords,
        const size_t numOfVertices)
    {
        if (indices == nullptr
            || positions == nullptr
            || normals == nullptr
            || texCoords == nullptr)
        {
            return std::nullopt;
        }

        std::vector<glm::vec3> tangents(numOfVertices, glm::vec3(0.0f));

        // Loop through each triangle
        for (size_t i = 0; i < numOfIndices; i += 3) {
            // Get vertex indices of the triangle
            int32 i1 = areIndices16Bit ? static_cast<int>(static_cast<const uint16*>(indices)[i + 0]) : static_cast<const int32*>(indices)[i];
            int32 i2 = areIndices16Bit ? static_cast<int>(static_cast<const uint16*>(indices)[i + 1]) : static_cast<const int32*>(indices)[i + 1];
            int32 i3 = areIndices16Bit ? static_cast<int>(static_cast<const uint16*>(indices)[i + 2]) : static_cast<const int32*>(indices)[i + 2];

            // Calculate triangle edges
            glm::vec3 edge1 = positions[i2] - positions[i1];
            glm::vec3 edge2 = positions[i3] - positions[i1];

            // UV deltas
            glm::vec2 deltaUV1 = texCoords[i2] - texCoords[i1];
            glm::vec2 deltaUV2 = texCoords[i3] - texCoords[i1];

            // Calculate tangent
            float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);
            glm::vec3 tangent;
            tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
            tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
            tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);

            // Add tangent to the vertices' tangent
            tangents[i1] += tangent;
            tangents[i2] += tangent;
            tangents[i3] += tangent;
        }

        // Normalize tangents
        for (size_t i = 0; i < numOfVertices; ++i) {
            tangents[i] = glm::normalize(tangents[i]);
        }

        return tangents;
    }
}